# 简介

Paillier同态加密是由Pascal Paillier于1999年提出并命名的密码学理论。它是一种基于公私钥密码学的概率非对称算法。

这套理论是一个加法同态加密算法，意味着，只要给定公钥和需要加密的信息$m_1$和$m_2$，就可以计算加密后的$m_1$和$m_2$之和，再可以用私钥解密结果，这整个过程精度没有损失。

> Paillier同态加密可以直接在密文上计算，然后解密就行了。

# 算法理论

首先回顾一下二项式定理。$n \in \mathbb{N}^{*}$
$$
(a+b)^{n}=\sum_{r=0}^{n} C_{n}^{r} a^{n-r} b^{r}=C_{n}^{0} a^{n}+C_{n}^{1} a^{n-1} b+\cdots+C_{n}^{r} a^{n-r} b^{r}+\cdots+C_{n}^{n} b^{n}
$$
当$a=1, b=n, n=x$时可以化成下面的形式：
$$
(1+n)^{x}=1+n x+\frac{x(x-1) n^{2}}{2 !} +...
$$
可以化为：
$$
(1+n)^{x} \equiv 1+n x\left(\bmod n^{2}\right)
$$

> mod是求余符号。这个表达式的意思是，$(1+n)^{x}$ 对$n^{2}$求余后的结果，与$1+n x$对$n^{2}$求余的结果相等

令$y=(1+n)^{x} \bmod n^{2}$，可化简为$x \equiv \frac{y-1}{n} \quad\left(\bmod n^{2}\right)$，再令$L(u)=\frac{u-1}{n}$

则
$$
L\left((1+n)^{x} \bmod n^{2}\right) \equiv L\left(y\right) \equiv \frac{y-1}{n}\quad(\bmod n) \equiv x \quad(\bmod n)
$$
即$L\left((1+n)^{x} \bmod n^{2}\right) \equiv x \quad(\bmod n)$

## Paillier同态加密

1. 随机选择两个比较大的素数p和q，并且保证$gcd(pq, (p-1)(q-1))=1$。gcd是求最大公因数，满足$gcd(pq, (p-1)(q-1))=1$，说明p和q的位数是相同的。
2. 令$n=pq$，$\lambda = lcm(p-1, q-1)$。lcm是求最小公倍数。
3. 随机选择一个整数$g$，$g \in \mathbb{Z}_{n^{2}}^{*}$
4. 令$\mu=\left(L\left(g^{\lambda} \bmod n^{2}\right)\right)^{-1} \bmod n$，其中确保存在 [modular multiplicative inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse)。

> 在这里modular multiplicative inverse不用特别注意，肯定满足的这个条件的，往下看。

如果p和q位数相等，令$g=n+1, \lambda=\varphi(n),$ and $\mu=\varphi(n)^{-1} \bmod n,$  $\varphi(n)=(p-1)(q-1)$可以满足上面几条规则。

公钥是$(n, g)$，公钥用于加密

私钥是$(\lambda, \mu)$，私钥用于解密

### 加密

1. 假设$m$为明文，是需要加密的信息，并且$0 \leq m<n$
2. 随机选择一个$r$，并且$0<r<n$, $r \in \mathbb{Z}_{n}^{*}$ 和$g c d(r, n)=1$
3. 密文$c=g^{m} \cdot r^{n} \bmod n^{2}$

### 解密

$m=L\left(c^{\lambda} \bmod n^{2}\right) \cdot \mu \bmod n$

### 证明如下

将$c=g^{m} \cdot r^{n} \bmod n^{2}$代入$m=L\left(c^{\lambda} \bmod n^{2}\right) \cdot \mu \bmod n$可得
$$
m =L\left(g^{\lambda m} \cdot r^{\lambda n} \bmod n^{2}\right) \cdot \mu \bmod n = \lambda m \cdot \mu \bmod n =  \lambda m \cdot \frac{1}{\lambda} \bmod n
$$
其中，$r^{\lambda n} \bmod n^{2} = 1$，其实$n$并不是一般的数，而是一个**Carmichael number**。

[Carmichael number](https://en.wikipedia.org/wiki/Carmichael's_theorem)的定义是，对于一个合数$n$，如果所有与$n$互质的正整数$b$，都有$b^{n-1} \equiv 1\left(\bmod n^{2}\right)$成立，则$n$称为Carmichael number。其中$0 < b < n$

$b^{n-1} \equiv 1\left(\bmod n^{2}\right)$的意思是，$b^{n-1}$对$n^2$求余的值与1相等。

$r^{\lambda n} \bmod n^{2} = 1$其实是Carmichael's theorem的一个推论，这里不再详细说明。

$L\left(g^{\lambda m} \bmod n^{2}\right) \equiv \lambda m \quad(\bmod n)$这里可以由上面二项式定理部分得出。

> 对两个数的乘积求余，与对这两个数先求余再相乘的结果相同。

## Paillier同态加密性质

### 加法

$$
D\left(E\left(m_{1}, r_{1}\right) \cdot E\left(m_{2}, r_{2}\right) \bmod n^{2}\right)=m_{1}+m_{2} \bmod n
$$

这个公式的意思是，明文$m_1$和$m_2$，随机选择的加密因子$r_1$和$r_2$。$m_1$和$m_2$加密后相乘再解密的结果，与$m_1 + m_2$对$n$求余的结果相同。
$$
D\left(E\left(m_{1}, r_{1}\right) \cdot g^{m_{2}} \bmod n^{2}\right)=m_{1}+m_{2} \bmod n
$$

### 乘法

$$
D\left(E\left(m_{1}, r_{1}\right)^{m_{2}} \bmod n^{2}\right)=m_{1} m_{2} \bmod n
$$

$$
D\left(E\left(m_{2}, r_{2}\right)^{m_{1}} \bmod n^{2}\right)=m_{1} m_{2} \bmod n
$$

一般地
$$
D\left(E\left(m_{1}, r_{1}\right)^{k} \bmod n^{2}\right)=k m_{1} \bmod n
$$

### 证明

这里只证明公式(6)，其他的公式的证明与此都是类似的。
$$
E\left(m_{1}, r_{1}\right) = c_1 = g^{m1} \cdot r_1^{n} \bmod n^{2}
$$

$$
E\left(m_{2}, r_{2}\right) = c_2 = g^{m2} \cdot r_2^{n} \bmod n^{2}
$$

$$
c_1 \cdot  c_2= g^{m1 + m2} \cdot (r_1 \cdot r_2)^{n} \bmod n^{2}
$$

$$
D\left(c_1 \cdot  c_2\right) \equiv L\left(g^{\lambda(m_1 + m_2)} \cdot (r_1 \cdot r_2)^{\lambda n} \bmod n^{2}\right) \cdot \mu \bmod n \\ \equiv \lambda (m_1 + m_2) \cdot \mu \quad(\bmod n) \\ \equiv m_{1}+m_{2} \quad(\bmod n)
$$

其中$(r_1 \cdot r_2)^{\lambda n} \equiv 1\left(\bmod n^{2}\right)$，依然是利用Carmichael's theorem。也不要忘了$\mu = \lambda ^{-1}$。

证毕。

# 实战

这里主要是利用[python-paillier](https://github.com/data61/python-paillier)开源库使用一下同态加密。

## 安装paillier

```
pip3 install phe
```

## 使用

```python
from phe import paillier
# 生成公钥、私钥
public_key, private_key = paillier.generate_paillier_keypair()

secret_number_list = [3.141592653, 50000, -4.6e-12]
# 加密
encrypted = [public_key.encrypt(x) for x in secret_number_list]
# print(encrypted)
# 解密
decrypted = [private_key.decrypt(x) for x in encrypted]
print(decrypted)
```

我们可以看下p、q的值和加密后的结果：

p

```
1758244117241871270451181711936927378658916851135093246753068965704485529054648109557144394573259681399744292712671058039426817211010490570409306604297886141152868937284582062138112406733477512755929323707214538332342044351693933611649857207220600936239062316751726722695929008411793268171572452365889938772852293883289085580724048588769717782371483001544498874988353471375106043794656801472273145135087538359695711896030537823444719064580224018576100248973114199
```

q

```
2391746262287096678009862671278112852508174119019981182511251638851571661546766300689861042433281757196313413904474956303420023796871665278982790122911937680885001272769868933425948638604899592198945143300023818931720815347225520193149860962102155159091720360544732727155631258719378409059269523502171905002772554573809846022514594762571010353800131808117883074651094376387785811954566395638284581122417480333268200458155718600740733172591173174535767003349991179
```

3.141592653加密后的结果

```
13819741667573291349316964913097387517384046780611988599218857230254599219133851239823752120790251602528120159204723780428790238977156333655288912067109901417107466981794809211660731460203913827187210908228717179579436126660766071137808040649513833234898840636530906045597849140519342318267474702672146538020573419179181026751937010506123100806871530578092055877105282257545402567868840015853346255433993427729552634933093768164281084421659844667421028781168981053961497999469319286225137873267652470388718670307373105786517372002046433237528017205078140822809326464752627128034080702818854910868603682261591633557764019447413732452845269269258375973630646255435129506552799113343815567976329545125488247328221246097446224465411608106195999024262635555776057385855907435614342468177136089192696030433437435596000234264781513539809493660382132079026512146737288684989759852616186223294774225145882886454712626876767169950780886005441437868649827007634279100367279706751870853875351663603770911013679970448300928622188856310915637509117673517283472512859139796282578170826709338399412342802266315302934121970744136985435625594029113688457005345613126337811383521312723024164168896894926904721581386614102761534712010824932682343522354752484687445230711866880950302358131005119652004734683142008002296040810028040371013005778015235228672579876423525846734206849291714804796212917750660143026016318683387872471349269701185819513513021570517160448703617324832902263837918258393235161405425441507205143961324829926901544540658736958498060014083732817510074124961326786758133761195310217713739498921769766014176909903573619132952335055559162195100862490387941781290267407182390079605790364723480841810853922048250981850474238188462030713881396323234778098818653497323178222538836388450977166449727542126011833319790272707065035705963509756465277026946981185
```

50000加密后的结果

```
7093128266164258991707578802276903179487209152879687167056393957987821023496101337469363264390943956320720294379723104389114699349684667630233764173243345367213479614890137489450086760351188406730581241780231895657796268580427473553768544278385625431468922596406141243273696179859880406233739826251421618195421352886358298451825755363868813568509207017570425820553479473459099379698257196246057023355104524355113462600989007359417697619457528287874976060878776811121922002119631482021102335878382987558130881028065947988045681465729324727756089917646135789142619191671205899250114551132753070880652894998792943099001045875628054356999615692058982161741857327400413057286263276311446162823582354148183123952257760891937970202226946237554414645787609126007158432988132047328381825238242306004540014874681338248536031703623620905406813236637654773800949307080102746207843765431399668041940394847305552418727523439938748845474426961325170038113736271523030441046435537453387092010935051874572319522561434670812083519381395368936650062713119020141238701296130913920852271581115420925298327838140018319136850686580857032289632988774690406389994585496854449896527027965559682022625736426129871879305159498020674781103233137649108648143622425446276453493832997875719647887634346241808798817785288002298271172186484544620220575557576404349309543800441649185144914298114283865421936461384485583688117745136621129469751062627911790738730371234572808570478097414567477458479705913530090888142361764586273237367111680124376685111878279379713353619887068829161919159257356388973140988568503150430281034837361797265628990806211663510898048938980197860518633190342037176565491773868580035095020735512632673756875828785439082122870902050143412417849976260290170617262274532160556314412356517797390198276488117607951206230874810943238181618111150999369610283757267447
```

-4.6e-12加密后的结果

```
17274904083555647475352617026554261134920396326691197783794354808006482765875457025000369895909933560108848305873468773096368144353374759751612592359705752437133655314131839473417222874838306481632894141032159591639956541226174412934977840621486809027789464646248614844612381190181589729060709693850873323931640716670981531847430367481644365211772803587213270325348866589832895896835433078382787100895502153498811413194244046915687470413348864227344663722127523757467704003524572116795059678835647067866404076866771341137741551570345684093559904560298294433899105446137365234894575913789343706416912590713779423189825019509951062389252744496921766085735284163498536067978669827282620838678525685721953681556053398076529348317319542729634245063897069171991793959240712577145208917781914570322504827761373407372699408328088070936435567843994688976137170266189497966431645580983353204164628187912287736915264923108108428342978264269355784004767226813410468600044289536343381596541159675377914026266066357478452387453509631567742013096320655697845361433828351424122608766590194360252897322449107553680972227662775463726301546877472289156174818198655241526629942686815731841038117280754801186276526487932518443860398685471449188872656093594145938514993350323837833115980226672547018523366209194465949816387399410160558598050438573981448591048896187398134329181477205981906692870554326514996774840200979741952806348051543428846277064125772978236584575822287273637806927149262381831081044443924988467525044717188197587254502232983673744091626882187623634194835938141078354188580843278417645829931110629118913754491690244137879882804084181769905481629670301314749799437142172143449903995823876748684845536069394984835490722116476241405840643191717699633390339237003467979430646060246576100386932860495616028150350916448310490218903889826694615824406895220483
```

> 为什么加密若干次数后需要重新生成公钥和私钥？

Carmichael 数，也就是这里的$n$，是非常少的，据统计，在1~100000000范围内的整数中，只有255个Carmichael 数；与$n$互质且$0<r<n$, $r \in \mathbb{Z}_{n}^{*}$的$r$也是有限的，从上面输出的p、q可以看出，n已经非常大了，但是$r$的选择并不是无穷的，如果选择到了重复的$r$，密文$c$就具有一定得相似性，明文$m$就有泄露的风险，所以加密若干次数后一般需要重新生成公钥和私钥。

从p、q的数量级可以看出，频繁重新生成公钥和私钥也是没有必要的，$n$非常大，满足条件的$r$很多。

### 参考链接

* [Carmichael's theorem](https://en.wikipedia.org/wiki/Carmichael's_theorem)
* [Modular multiplicative inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse)
* [Paillier cryptosystem](https://en.wikipedia.org/wiki/Paillier_cryptosystem)
* Paillier. 1999. Public-Key Cryptosystems Based on Composite Degree Residuosity Classes
* [python-paillier](https://github.com/data61/python-paillier)

